# BasicRPC Implementation Overview
This document provides an overview of the basic RPC (Remote Procedure Call) framework, focusing on the client-server architecture, core components, and the benefits of using a thread pool in the server for handling requests efficiently.

## Table of Contents
1. [Introduction](#introduction)
2. [Architecture Overview](#architecture-overview)
3. [Core Components](#core-components)
4. [Workflow](#workflow)
5. [Benefits of Using a Thread Pool](#benefits-of-using-a-thread-pool)
6. [Future Enhancements](#future-enhancements)

---

### 1. Introduction

This RPC framework allows a client to remotely invoke methods on a server as though they were local method calls. The client-server communication is abstracted, so the client does not need to handle the underlying network details. This document provides an in-depth look at the client and server components, and explains how a thread pool enhances the serverâ€™s ability to handle multiple client requests efficiently.

### 2. Architecture Overview

The system follows a client-server architecture:
- **Client Proxy**: Intercepts client method calls, converts them into RPC requests, and sends them to the server.
- **Server**: Listens for client requests and handles them using a thread pool to improve concurrency.
- **Transport Layer**: Manages data exchange between the client and server using sockets.

![Architecture Diagram](https://raw.githubusercontent.com/HeZephyr/NewPicGoLibrary/main/img/image-20241026223521520.png)

### 3. Core Components

#### 3.1 `ClientProxy`
Located at: `src/main/java/rpc/basic/client/proxy/ClientProxy.java`

- **Purpose**: Acts as a dynamic proxy on the client side, intercepting calls to interface methods, creating `RpcRequest` objects, and sending them to the server.
- **Key Methods**:
   - `invoke`: Captures method details, packages them in an `RpcRequest`, and sends it to the server. Receives and returns the result from the server.
   - `getProxy`: Creates a proxy instance for the specified interface, allowing the client to call methods as if they were local.

#### 3.2 `RpcRequest` and `RpcResponse`
Located at: `src/main/java/rpc/basic/common/message`

- **`RpcRequest`**: Encapsulates details of the method being called, including interface name, method name, parameter types, and arguments.
- **`RpcResponse`**: Encapsulates the result of the method call, including any returned data or error status.

#### 3.3 `ThreadPoolRpcServer`
Located at: `src/main/java/rpc/basic/server/impl/ThreadPoolRpcServer.java`

`ThreadPoolRpcServer` is the main server component that uses a thread pool to handle client requests concurrently:
- **Service Provider**: Holds references to server-side implementations of interfaces, allowing the server to invoke the correct service.
- **Thread Pool**: Utilizes `ThreadPoolExecutor` to manage and execute `WorkerThread` instances that handle individual client requests. This approach reduces the overhead of thread creation and destruction.
- **Server Socket**: Listens for incoming client connections and passes them to the thread pool for processing.

#### 3.4 `WorkerThread`
Located at: `src/main/java/rpc/basic/server/work/WorkerThread.java`

Each `WorkerThread`:
- Reads an `RpcRequest` from the client.
- Uses Java reflection to invoke the specified method.
- Writes the result back as an `RpcResponse` to the client.

### 4. Workflow

The following steps describe the overall workflow of the RPC system:

1. **Client-Side Method Invocation**:
   - The client calls a method on a proxy object generated by `ClientProxy`. For example, `UserService proxy.getUserById(1);`.

2. **Client Proxy Interception**:
   - `ClientProxy` intercepts the call, creates an `RpcRequest`, and sends it to the server via `IOClient`.

3. **Server Request Handling**:
   - The `ThreadPoolRpcServer` listens for incoming connections and hands each new connection to a `WorkerThread` from the thread pool.

4. **Request Processing in `WorkerThread`**:
   - `WorkerThread` deserializes the `RpcRequest`, finds the target method, and invokes it using reflection. The result is packaged in an `RpcResponse`.

5. **Response Transmission**:
   - The `WorkerThread` serializes the `RpcResponse` and sends it back to the client.

6. **Client Receives Result**:
   - The client proxy receives the `RpcResponse`, extracts the result, and returns it as the outcome of the original method call.

### 5. Benefits of Using a Thread Pool

The `ThreadPoolRpcServer` class utilizes a thread pool to manage resources efficiently while handling multiple client requests. The advantages include:

- **Improved Performance**: Reusing threads avoids the overhead of frequent thread creation and destruction, leading to faster response times for client requests.
- **Scalability**: Allows the server to handle many concurrent requests by limiting the number of active threads, balancing load and resource usage.
- **Controlled Resource Usage**: Configurable core and maximum pool sizes, along with a request queue, prevent resource exhaustion and stabilize the server under heavy load.
- **Enhanced Stability**: By using a bounded queue and rejecting excess tasks, the thread pool helps the server maintain performance and avoid crashes when overloaded.

### 6. Future Enhancements

To further improve this RPC framework, the following features can be added:

- **Dynamic Thread Pool Sizing**: Adjust thread pool size based on real-time load for more efficient resource use.
- **Graceful Shutdown**: Implement a process that allows active requests to complete before shutting down the server.
- **Load Balancing**: Distribute incoming requests among multiple server instances for better scalability.
- **Monitoring and Metrics**: Add metrics for active threads, queue size, and request processing time to optimize server performance.

---